function y = quick_sort_iter(x)
    %   y = QUICK_SORT_ITER(x) возвращает отсортированный по возрастанию вектор y,
    %   содержащий те же элементы, что и входной вектор x, без рекурсивных вызовов.
    
    y = x;                      % Рабочая копия массива
    n = length(y);              % Размер массива
    if n < 2 return             % Если элементов меньше 2, сразу выходим
    end
    
    % Стек для хранения поддиапазонов [left, right]
    stack = zeros(n, 2);
    top = 0;                    % Указатель на вершину стека
    
    % Инициализируем стек полным диапазоном
    top = top + 1;
    stack(top, :) = [1, n];
    
    % Пока есть диапазоны для обработки
    while top > 0
        % Извлекаем границы текущего подмассива
        range = stack(top, :);
        top = top - 1;
        left  = range(1);
        right = range(2);
        
        if left < right
            % Выбираем опорный элемент: здесь — последний в поддиапазоне
            pivot = y(right);
            i = left - 1;
            
            % Перестановка элементов: < pivot влево, >= pivot — вправо
            for j = left:right-1
                if y(j) < pivot
                    i = i + 1;
                    % Обмен y(i) и y(j)
                    tmp   = y(i);
                    y(i)  = y(j);
                    y(j)  = tmp;
                end
            end
            
            % Поместить pivot на своё место (между «меньшими» и «большими»)
            pivotPos = i + 1;
            y(right)        = y(pivotPos);
            y(pivotPos)     = pivot;
            
            % Добавляем в стек два новых поддиапазона, которые нужно отсортировать
            % (можно добавлять в любом порядке, здесь — сначала левый, потом правый)
            
            % Правый поддиапазон: элементы после pivot
            top = top + 1;
            stack(top, :) = [pivotPos + 1, right];
            
            % Левый поддиапазон: элементы до pivot
            top = top + 1;
            stack(top, :) = [left, pivotPos - 1];
        end
    end
end
